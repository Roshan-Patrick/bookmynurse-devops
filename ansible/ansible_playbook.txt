---
# ansible/playbook.yaml
# BookMyNurse Server Provisioning Playbook

- name: BookMyNurse DevOps Infrastructure Setup
  hosts: "{{ target_host_group }}"
  become: yes
  gather_facts: yes

  # Define all necessary variables here to ensure the playbook can run non-interactively.
  vars:
    app_name: "bookmynurse"
    k8s_version: "1.30"
    k8s_pod_network_cidr: "10.244.0.0/16" # Default for Flannel CNI
    docker_users:
      - root
    letsencrypt_email: "your-email@example.com" # <-- IMPORTANT: Change this to your actual email
    domain_name: "app.bookmynurse.com" # Used for summary, not configuration

  pre_tasks:
    - name: Verify migration confirmation
      fail:
        msg: "Migration cancelled by user"
      when: confirm_migration != "yes"

    - name: Display server information
      debug:
        msg: |
          Server: {{ inventory_hostname }}
          IP: {{ ansible_host }}
          Port: {{ ansible_port }}
          OS: {{ ansible_distribution }} {{ ansible_distribution_version }}

  tasks:
    # Phase 1: Backup and Preparation
    - name: Phase 1 - Backup Current Setup
      block:
        - name: Create backup directory
          file:
            path: /backup/ansible_migration_{{ ansible_date_time.epoch }}
            state: directory
            mode: '0755'
          register: backup_dir

        - name: Backup Apache configuration
          copy:
            src: /etc/apache2
            dest: "{{ backup_dir.path }}/apache2_backup"
            remote_src: yes
          ignore_errors: yes

        - name: Backup website files
          copy:
            src: /var/www/bnm
            dest: "{{ backup_dir.path }}/website_backup"
            remote_src: yes
          ignore_errors: yes

        - name: Backup SSL certificates
          copy:
            src: /etc/letsencrypt
            dest: "{{ backup_dir.path }}/ssl_backup"
            remote_src: yes
          ignore_errors: yes

        - name: Create backup archive
          archive:
            path: "{{ backup_dir.path }}"
            dest: "/backup/ansible_backup_{{ ansible_date_time.epoch }}.tar.gz"
            format: gz

        - name: Display backup information
          debug:
            msg: |
              Backup created: /backup/ansible_backup_{{ ansible_date_time.epoch }}.tar.gz

    # Phase 2: System Updates and Dependencies
    - name: Phase 2 - System Updates
      block:
        - name: Update apt cache
          apt:
            update_cache: yes
            cache_valid_time: 3600

        - name: Fix broken dependencies if any
          shell: DEBIAN_FRONTEND=noninteractive apt-get install -f -y

        - name: Configure any partially installed packages
          shell: DEBIAN_FRONTEND=noninteractive dpkg --configure -a

        - name: Upgrade system packages (dist-upgrade)
          apt:
            upgrade: dist
            update_cache: yes
          environment:
            DEBIAN_FRONTEND: noninteractive

        - name: Install required packages
          apt:
            name:
              - apt-transport-https
              - ca-certificates
              - curl
              - gnupg
              - lsb-release
              - software-properties-common
              - python3-pip
              - unzip
              - wget
              - git
              - htop
              - vim
              - ufw
            state: present

    # Phase 3: Docker Installation
    - name: Phase 3 - Docker Installation
      block:
        - name: Remove old Docker installations
          apt:
            name:
              - docker
              - docker-engine
              - docker.io
              - containerd
              - runc
            state: absent

        - name: Download Docker GPG key
          get_url:
            url: https://download.docker.com/linux/ubuntu/gpg
            dest: /usr/share/keyrings/docker-archive-keyring.gpg
            mode: '0644'

        - name: Remove ALL conflicting Docker apt repository entries (before adding correct one)
          file:
            path: "/etc/apt/sources.list.d/docker.list"
            state: absent

        - name: Remove Docker repo from /etc/apt/sources.list
          lineinfile:
            path: /etc/apt/sources.list
            regexp: '^deb .*download.docker.com.*$'
            state: absent

        - name: Remove old Docker apt repository if present
          apt_repository:
            repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
            state: absent
            filename: 'docker'

        - name: Add Docker apt repository
          apt_repository:
            repo: "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
            state: present
            filename: 'docker'

        - name: Install Docker
          apt:
            name:
              - docker-ce
              - docker-ce-cli
              - containerd.io
              - docker-buildx-plugin
              - docker-compose-plugin
            state: present
            update_cache: yes

        - name: Start and enable Docker
          systemd:
            name: docker
            state: started
            enabled: yes

        - name: Configure Docker daemon for CRI
          copy:
            content: |
              {
                "exec-opts": ["native.cgroupdriver=systemd"],
                "log-driver": "json-file",
                "log-opts": {
                  "max-size": "100m"
                },
                "storage-driver": "overlay2"
              }
            dest: /etc/docker/daemon.json
            mode: '0644'
          notify: restart docker

        - name: Create Docker service drop-in directory
          file:
            path: /etc/systemd/system/docker.service.d
            state: directory
            mode: '0755'

        - name: Configure Docker service for CRI
          copy:
            content: |
              [Service]
              ExecStart=
              ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
            dest: /etc/systemd/system/docker.service.d/override.conf
            mode: '0644'
          notify: restart docker

        - name: Configure containerd for Docker
          copy:
            content: |
              version = 2
              [plugins."io.containerd.grpc.v1.cri"]
                sandbox_image = "registry.k8s.io/pause:3.9"
                stream_server_address = "127.0.0.1"
                stream_server_port = "0"
                enable_selinux = false
                enable_tls_streaming = false
                max_container_log_line_size = 16384
                disable_cgroup = false
                disable_apparmor = false
                restrict_oom_score_adj = false
                max_concurrent_downloads = 3
                disable_proc_mount = false
                unset_seccomp_profile = ""
                tolerate_missing_hugetlb_controller = true
                ignore_image_defined_volumes = false
                [plugins."io.containerd.grpc.v1.cri".containerd]
                  snapshotter = "overlayfs"
                  default_runtime_name = "runc"
                  disable_snapshot_annotations = true
                  discard_unpacked_layers = false
                  no_pivot = false
                  disable = false
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes]
                  [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
                    runtime_type = "io.containerd.runc.v2"
                    runtime_engine = ""
                    runtime_root = ""
                    privileged_without_host_devices = false
                    base_runtime_spec = ""
                    [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
                      SystemdCgroup = true
            dest: /etc/containerd/config.toml
            mode: '0644'
          notify: restart containerd

        - name: Add users to docker group
          user:
            name: "{{ item }}"
            groups: docker
            append: yes
          loop: "{{ docker_users }}"

        - name: Test Docker installation
          command: docker --version
          register: docker_version

        - name: Display Docker version
          debug:
            msg: "Docker installed: {{ docker_version.stdout }}"

    # Phase 4: Kubernetes Installation
    - name: Phase 4 - Kubernetes Installation
      block:
        - name: Disable swap
          shell: |
            swapoff -a
            sed -i '/ swap / s/^\\(.*\\)$/#\\1/g' /etc/fstab

        - name: Load kernel modules
          modprobe:
            name: "{{ item }}"
            state: present
          loop:
            - overlay
            - br_netfilter

        - name: Configure kernel modules to load on boot
          copy:
            dest: /etc/modules-load.d/k8s.conf
            content: |
              overlay
              br_netfilter

        - name: Configure sysctl parameters
          copy:
            dest: /etc/sysctl.d/k8s.conf
            content: |
              net.bridge.bridge-nf-call-iptables  = 1
              net.bridge.bridge-nf-call-ip6tables = 1
              net.ipv4.ip_forward                 = 1
          notify: reload sysctl

        - name: Remove legacy Kubernetes repo source if present
          file:
            path: /etc/apt/sources.list.d/kubernetes.list
            state: absent

        - name: Download Kubernetes GPG key
          get_url:
            url: https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key
            dest: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
            mode: '0644'

        - name: Add Kubernetes apt repository
          apt_repository:
            repo: "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /"
            state: present
            filename: 'kubernetes.list'

        - name: Install Kubernetes components
          apt:
            name:
                - "kubelet={{ k8s_version }}.*"
                - "kubeadm={{ k8s_version }}.*"
                - "kubectl={{ k8s_version }}.*"
            state: present
            update_cache: yes

        - name: Hold Kubernetes packages
          dpkg_selections:
            name: "{{ item }}"
            selection: hold
          loop:
            - kubelet
            - kubeadm
            - kubectl

        - name: Check disk space and memory before kubeadm
          shell: |
            df -h
            free -m
          register: sys_resources

        - name: Debug system resources
          debug:
            var: sys_resources.stdout_lines

        - name: Reset any existing Kubernetes cluster
          shell: |
            kubeadm reset -f || true
            systemctl restart docker || true
            systemctl restart kubelet || true
          ignore_errors: yes

        - name: Initialize Kubernetes cluster
          command: kubeadm init --pod-network-cidr={{ k8s_pod_network_cidr }}
          register: kubeadm_output
          failed_when: kubeadm_output.rc != 0

        - name: Debug kubeadm output
          debug:
            msg: "Kubeadm stdout: {{ kubeadm_output.stdout_lines }}"
          when: kubeadm_output.rc != 0

        - name: Debug kubeadm error
          debug:
            msg: "Kubeadm stderr: {{ kubeadm_output.stderr_lines }}"
          when: kubeadm_output.rc != 0

        - name: Create .kube directory
          file:
            path: /root/.kube
            state: directory
            mode: '0755'
          when: kubeadm_output.rc == 0

        - name: Copy admin.conf to user's kube config
          copy:
            src: /etc/kubernetes/admin.conf
            dest: /root/.kube/config
            remote_src: yes
            owner: root
            group: root
            mode: '0644'
          when: kubeadm_output.rc == 0

        - name: Install Flannel CNI
          shell: kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
          when: kubeadm_output.rc == 0

        - name: Remove master taint (for single-node cluster)
          shell: kubectl taint nodes --all node-role.kubernetes.io/control-plane-
          when: kubeadm_output.rc == 0
          ignore_errors: yes

    # Phase 5: Nginx Ingress Controller
    - name: Phase 5 - Nginx Ingress Controller
      block:
        - name: Install Nginx Ingress Controller
          shell: |
            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.1/deploy/static/provider/baremetal/deploy.yaml
            sed -i 's/hostPort: 80/hostPort: 8080/g' /tmp/ingress-deploy.yaml
            sed -i 's/hostPort: 443/hostPort: 8443/g' /tmp/ingress-deploy.yaml
            kubectl apply -f /tmp/ingress-deploy.yaml
          when: kubeadm_output.rc == 0

        - name: Wait for Nginx Ingress Controller to be ready
          shell: kubectl wait --namespace ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=300s
          when: kubeadm_output.rc == 0

        - name: Patch Nginx Ingress Controller service
          shell: |
            kubectl patch svc ingress-nginx-controller -n ingress-nginx -p '{"spec": {"type": "LoadBalancer", "externalIPs":["{{ ansible_host }}"]}}'
          when: kubeadm_output.rc == 0

    # Phase 6: Cert-Manager Installation
    - name: Phase 6 - Cert-Manager Installation
      block:
        - name: Install cert-manager
          shell: |
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
          when: kubeadm_output.rc == 0

        - name: Wait for cert-manager to be ready
          shell: kubectl wait --namespace cert-manager --for=condition=ready pod --selector=app.kubernetes.io/instance=cert-manager --timeout=300s
          when: kubeadm_output.rc == 0

        - name: Create ClusterIssuer for Let's Encrypt
          copy:
            dest: /tmp/letsencrypt-issuer.yaml
            content: |
              apiVersion: cert-manager.io/v1
              kind: ClusterIssuer
              metadata:
                name: letsencrypt-prod
              spec:
                acme:
                  server: https://acme-v02.api.letsencrypt.org/directory
                  email: {{ letsencrypt_email }}
                  privateKeySecretRef:
                    name: letsencrypt-prod
                  solvers:
                  - http01:
                      ingress:
                        class: nginx
          when: kubeadm_output.rc == 0

        - name: Apply ClusterIssuer
          shell: kubectl apply -f /tmp/letsencrypt-issuer.yaml
          when: kubeadm_output.rc == 0

    # Phase 7: MySQL Setup
    - name: Phase 7 - MySQL Database Setup
      block:
        - name: Create MySQL namespace
          shell: kubectl create namespace {{ app_name }} --dry-run=client -o yaml | kubectl apply -f -
          when: kubeadm_output.rc == 0

        - name: Create MySQL secret
          shell: |
            kubectl create secret generic mysql-secret \
              --from-literal=root-password='{{ mysql_root_password }}' \
              --from-literal=user-password='{{ mysql_app_password }}' \
              --namespace {{ app_name }} \
              --dry-run=client -o yaml | kubectl apply -f -
          when: kubeadm_output.rc == 0

    # Phase 8: Firewall Configuration
    - name: Phase 8 - Firewall Configuration
      block:
        - name: Enable UFW
          ufw:
            state: enabled
            policy: deny
            direction: incoming

        - name: Configure basic UFW rules
          ufw:
            rule: allow
            port: "{{ item }}"
          loop:
            - "22"
            - "{{ ansible_port }}"
            - "80"
            - "443"
            - "6443"
            - "10250"

        - name: Check if NodePort TCP rule exists
          shell: ufw status numbered | grep "30000:32767/tcp" || echo "NOT_FOUND"
          register: tcp_rule_check
          changed_when: false

        - name: Allow Kubernetes NodePort range (TCP)
          ufw:
            rule: allow
            port: "30000:32767"
            proto: tcp
          when: "'NOT_FOUND' in tcp_rule_check.stdout"

        - name: Check if NodePort UDP rule exists
          shell: ufw status numbered | grep "30000:32767/udp" || echo "NOT_FOUND"
          register: udp_rule_check
          changed_when: false

        - name: Allow Kubernetes NodePort range (UDP)
          ufw:
            rule: allow
            port: "30000:32767"
            proto: udp
          when: "'NOT_FOUND' in udp_rule_check.stdout"

        - name: Allow Docker subnet
          ufw:
            rule: allow
            src: "172.17.0.0/16"

        - name: Allow Flannel subnet
          ufw:
            rule: allow
            src: "{{ k8s_pod_network_cidr }}"

    # Phase 9: Final Verification
    - name: Phase 9 - Final Verification
      block:
        - name: Check cluster status
          shell: kubectl get nodes
          register: cluster_nodes
          when: kubeadm_output.rc == 0

        - name: Check running pods
          shell: kubectl get pods --all-namespaces
          register: cluster_pods
          when: kubeadm_output.rc == 0

        - name: Display cluster information
          debug:
            msg: |
              Cluster Nodes:
              {{ cluster_nodes.stdout }}
              
              Cluster Pods:
              {{ cluster_pods.stdout }}
          when: kubeadm_output.rc == 0

        - name: Create deployment summary
          copy:
            dest: /root/deployment_summary.txt
            content: |
              BookMyNurse DevOps Migration Summary
              ===================================
              Date: {{ ansible_date_time.iso8601 }}
              Server: {{ inventory_hostname }}
              Domain: {{ domain_name }}
              
              Installed Components:
              - Docker: {{ docker_version.stdout }}
              - Kubernetes: {{ k8s_version }}
              - Nginx Ingress Controller: Installed
              - Cert-Manager: Installed
              - MySQL: Configured
              - Firewall: Configured

              Next Steps:
              - Apply Kubernetes manifests for application deployment.
              - Configure DNS records for {{ domain_name }}
  handlers:
    - name: reload sysctl
      command: sysctl --system

    - name: restart docker
      systemd:
        name: docker
        state: restarted

    - name: restart containerd
      systemd:
        name: containerd
        state: restarted