# ansible/playbook.yaml
# BookMyNurse Server Provisioning Playbook

- name: BookMyNurse DevOps Infrastructure Setup
  hosts: "{{ target_host_group }}"
  become: yes
  gather_facts: yes

  # Define all necessary variables here to ensure the playbook can run non-interactively.
  vars:
    app_name: "bookmynurse"
    k8s_version: "1.30"
    k8s_pod_network_cidr: "10.244.0.0/16" # Default for Flannel CNI
    docker_users:
      - root
    letsencrypt_email: "your-email@example.com" # <-- IMPORTANT: Change this to your actual email
    domain_name: "app.bookmynurse.com" # Used for summary, not configuration

  pre_tasks:
    - name: Verify migration confirmation
      fail:
        msg: "Migration cancelled by user"
      when: confirm_migration != "yes"

    - name: Display server information
      debug:
        msg: |
          Server: {{ inventory_hostname }}
          IP: {{ ansible_host }}
          Port: {{ ansible_port }}
          OS: {{ ansible_distribution }} {{ ansible_distribution_version }}

  tasks:
    # Phase 1: Backup and Preparation
    - name: Phase 1 - Backup Current Setup
      block:
        - name: Create backup directory
          file:
            path: /backup/ansible_migration_{{ ansible_date_time.epoch }}
            state: directory
            mode: '0755'
          register: backup_dir

        - name: Backup Apache configuration
          copy:
            src: /etc/apache2
            dest: "{{ backup_dir.path }}/apache2_backup"
            remote_src: yes
          ignore_errors: yes

        - name: Backup website files
          copy:
            src: /var/www/bnm
            dest: "{{ backup_dir.path }}/website_backup"
            remote_src: yes
          ignore_errors: yes

        - name: Backup SSL certificates
          copy:
            src: /etc/letsencrypt
            dest: "{{ backup_dir.path }}/ssl_backup"
            remote_src: yes
          ignore_errors: yes

        - name: Create backup archive
          archive:
            path: "{{ backup_dir.path }}"
            dest: "/backup/ansible_backup_{{ ansible_date_time.epoch }}.tar.gz"
            format: gz

        - name: Display backup information
          debug:
            msg: |
              Backup created: /backup/ansible_backup_{{ ansible_date_time.epoch }}.tar.gz

    # Phase 2: System Updates and Dependencies
    - name: Phase 2 - System Updates
      block:
        - name: Update apt cache
          apt:
            update_cache: yes
            cache_valid_time: 3600

        - name: Fix broken dependencies if any
          shell: DEBIAN_FRONTEND=noninteractive apt-get install -f -y

        - name: Configure any partially installed packages
          shell: DEBIAN_FRONTEND=noninteractive dpkg --configure -a

        - name: Upgrade system packages (dist-upgrade)
          apt:
            upgrade: dist
            update_cache: yes
          environment:
            DEBIAN_FRONTEND: noninteractive

        - name: Install required packages
          apt:
            name:
              - apt-transport-https
              - ca-certificates
              - curl
              - gnupg
              - lsb-release
              - software-properties-common
              - python3-pip
              - unzip
              - wget
              - git
              - htop
              - vim
              - ufw
            state: present

    # Phase 3: Docker Installation (Robust Method)
    - name: Phase 3 - Docker Installation
      block:
        - name: Download Docker convenience script
          get_url:
            url: https://get.docker.com
            dest: /tmp/get-docker.sh
            mode: '0755'

        - name: Install Docker using the convenience script
          command: /tmp/get-docker.sh
          args:
            creates: /usr/bin/docker

        - name: Add users to docker group
          user:
            name: "{{ item }}"
            groups: docker
            append: yes
          loop: "{{ docker_users }}"

        - name: Start and enable Docker service
          systemd:
            name: docker
            state: started
            enabled: yes

        - name: Verify Docker installation
          command: docker --version
          register: docker_version
          changed_when: false

        - name: Display Docker version
          debug:
            msg: "Docker installed: {{ docker_version.stdout }}"

    # Phase 4: Kubernetes Installation
    - name: Phase 4 - Kubernetes Installation
      block:
        - name: Disable swap
          shell: |
            swapoff -a
            sed -i '/ swap / s/^\\(.*\\)$/#\\1/g' /etc/fstab

        - name: Load kernel modules
          modprobe:
            name: "{{ item }}"
            state: present
          loop:
            - overlay
            - br_netfilter

        - name: Configure kernel modules to load on boot
          copy:
            dest: /etc/modules-load.d/k8s.conf
            content: |
              overlay
              br_netfilter

        - name: Configure sysctl parameters
          copy:
            dest: /etc/sysctl.d/k8s.conf
            content: |
              net.bridge.bridge-nf-call-iptables  = 1
              net.bridge.bridge-nf-call-ip6tables = 1
              net.ipv4.ip_forward                 = 1
          notify: reload sysctl

        - name: Remove legacy Kubernetes repo source if present
          file:
            path: /etc/apt/sources.list.d/kubernetes.list
            state: absent

        - name: Download Kubernetes GPG key
          get_url:
            url: https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key
            dest: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
            mode: '0644'

        - name: Add Kubernetes apt repository
          apt_repository:
            repo: "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /"
            state: present
            filename: 'kubernetes.list'

        - name: Install Kubernetes components
          apt:
            name:
                - "kubelet={{ k8s_version }}.*"
                - "kubeadm={{ k8s_version }}.*"
                - "kubectl={{ k8s_version }}.*"
            state: present
            update_cache: yes

        - name: Hold Kubernetes packages
          dpkg_selections:
            name: "{{ item }}"
            selection: hold
          loop:
            - kubelet
            - kubeadm
            - kubectl

        - name: Check disk space and memory before kubeadm
          shell: |
            df -h
            free -m
          register: sys_resources

        - name: Debug system resources
          debug:
            var: sys_resources.stdout_lines

        - name: Reset any existing Kubernetes cluster
          shell: |
            kubeadm reset -f || true
            systemctl restart docker || true
            systemctl restart kubelet || true
          ignore_errors: yes

        - name: Remove .kube directory
          file:
            path: /root/.kube
            state: absent

        - name: Ensure swap is disabled
          command: swapoff -a
          ignore_errors: yes

        - name: Remove swap entry from fstab
          replace:
            path: /etc/fstab
            regexp: '^\s*([^#].*\sswap\s.*)$'
            replace: '# \1'
          ignore_errors: yes

        - name: Verify kernel modules are loaded
          modprobe:
            name: "{{ item }}"
            state: present
          loop:
            - overlay
            - br_netfilter

        - name: Verify sysctl parameters
          sysctl:
            name: "{{ item.name }}"
            value: "{{ item.value }}"
            state: present
            reload: yes
          loop:
            - { name: 'net.bridge.bridge-nf-call-iptables', value: '1' }
            - { name: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
            - { name: 'net.ipv4.ip_forward', value: '1' }

        - name: Initialize Kubernetes cluster
          command: kubeadm init --pod-network-cidr={{ k8s_pod_network_cidr }}
          register: kubeadm_output
          ignore_errors: yes

        - name: Debug full kubeadm output
          debug:
            var: kubeadm_output
          when: kubeadm_output.rc != 0

        - name: Fail if kubeadm failed
          fail:
            msg: "Kubeadm initialization failed with return code {{ kubeadm_output.rc }}"
          when: kubeadm_output.rc != 0

        - name: Create .kube directory
          file:
            path: /root/.kube
            state: directory
            mode: '0755'
          when: kubeadm_output.rc == 0

        - name: Copy admin.conf to user's kube config
          copy:
            src: /etc/kubernetes/admin.conf
            dest: /root/.kube/config
            remote_src: yes
            owner: root
            group: root
            mode: '0644'
          when: kubeadm_output.rc == 0

        - name: Install Flannel CNI
          shell: kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
          when: kubeadm_output.rc == 0

        - name: Remove master taint (for single-node cluster)
          shell: kubectl taint nodes --all node-role.kubernetes.io/control-plane-
          when: kubeadm_output.rc == 0
          ignore_errors: yes

    # Phase 5: Nginx Ingress Controller
    - name: Phase 5 - Nginx Ingress Controller
      block:
        - name: Install Nginx Ingress Controller
          shell: |
            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.1/deploy/static/provider/baremetal/deploy.yaml
            kubectl patch service ingress-nginx-controller -n ingress-nginx --type='json' -p='[{"op": "replace", "path": "/spec/ports/0/port", "value":8080}, {"op": "replace", "path": "/spec/ports/1/port", "value":8443}]'
          when: kubeadm_output.rc == 0

        - name: Wait for Nginx Ingress Controller to be ready
          shell: kubectl wait --namespace ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=300s
          when: kubeadm_output.rc == 0

        - name: Patch Nginx Ingress Controller service
          shell: |
            kubectl patch svc ingress-nginx-controller -n ingress-nginx -p '{"spec": {"type": "LoadBalancer", "externalIPs":["{{ ansible_host }}"]}}'
          when: kubeadm_output.rc == 0

    # Phase 6: Cert-Manager Installation
    - name: Phase 6 - Cert-Manager Installation
      block:
        - name: Install cert-manager
          shell: |
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
          when: kubeadm_output.rc == 0

        - name: Wait for cert-manager to be ready
          shell: kubectl wait --namespace cert-manager --for=condition=ready pod --selector=app.kubernetes.io/instance=cert-manager --timeout=300s
          when: kubeadm_output.rc == 0

        - name: Create ClusterIssuer for Let's Encrypt
          copy:
            dest: /tmp/letsencrypt-issuer.yaml
            content: |
              apiVersion: cert-manager.io/v1
              kind: ClusterIssuer
              metadata:
                name: letsencrypt-prod
              spec:
                acme:
                  server: https://acme-v02.api.letsencrypt.org/directory
                  email: {{ letsencrypt_email }}
                  privateKeySecretRef:
                    name: letsencrypt-prod
                  solvers:
                  - http01:
                      ingress:
                        class: nginx
          when: kubeadm_output.rc == 0

        - name: Apply ClusterIssuer
          shell: kubectl apply -f /tmp/letsencrypt-issuer.yaml
          when: kubeadm_output.rc == 0

    # Phase 7: MySQL Setup
    - name: Phase 7 - MySQL Database Setup
      block:
        - name: Create MySQL namespace
          shell: kubectl create namespace {{ app_name }} --dry-run=client -o yaml | kubectl apply -f -
          when: kubeadm_output.rc == 0

        - name: Create MySQL secret
          shell: |
            kubectl create secret generic mysql-secret \
              --from-literal=root-password='{{ mysql_root_password }}' \
              --from-literal=user-password='{{ mysql_app_password }}' \
              --namespace {{ app_name }} \
              --dry-run=client -o yaml | kubectl apply -f -
          when: kubeadm_output.rc == 0

    # Phase 8: Firewall Configuration
    - name: Phase 8 - Firewall Configuration
      block:
        - name: Enable UFW
          ufw:
            state: enabled
            policy: deny
            direction: incoming

        - name: Configure basic UFW rules
          ufw:
            rule: allow
            port: "{{ item }}"
          loop:
            - "22"
            - "{{ ansible_port }}"
            - "80"
            - "443"
            - "6443"
            - "10250"

        - name: Check if NodePort TCP rule exists
          shell: ufw status numbered | grep "30000:32767/tcp" || echo "NOT_FOUND"
          register: tcp_rule_check
          changed_when: false

        - name: Allow Kubernetes NodePort range (TCP)
          ufw:
            rule: allow
            port: "30000:32767"
            proto: tcp
          when: "'NOT_FOUND' in tcp_rule_check.stdout"

        - name: Check if NodePort UDP rule exists
          shell: ufw status numbered | grep "30000:32767/udp" || echo "NOT_FOUND"
          register: udp_rule_check
          changed_when: false

        - name: Allow Kubernetes NodePort range (UDP)
          ufw:
            rule: allow
            port: "30000:32767"
            proto: udp
          when: "'NOT_FOUND' in udp_rule_check.stdout"

        - name: Allow Docker subnet
          ufw:
            rule: allow
            src: "172.17.0.0/16"

        - name: Allow Flannel subnet
          ufw:
            rule: allow
            src: "{{ k8s_pod_network_cidr }}"

    # Phase 9: Final Verification
    - name: Phase 9 - Final Verification
      block:
        - name: Check cluster status
          shell: kubectl get nodes
          register: cluster_nodes
          when: kubeadm_output.rc == 0

        - name: Check running pods
          shell: kubectl get pods --all-namespaces
          register: cluster_pods
          when: kubeadm_output.rc == 0

        - name: Display cluster information
          debug:
            msg: |
              Cluster Nodes:
              {{ cluster_nodes.stdout }}
              
              Cluster Pods:
              {{ cluster_pods.stdout }}
          when: kubeadm_output.rc == 0

        - name: Create deployment summary
          copy:
            dest: /root/deployment_summary.txt
            content: |
              BookMyNurse DevOps Migration Summary
              ===================================
              Date: {{ ansible_date_time.iso8601 }}
              Server: {{ inventory_hostname }}
              Domain: {{ domain_name }}
              
              Installed Components:
              - Docker: {{ docker_version.stdout }}
              - Kubernetes: {{ k8s_version }}
              - Nginx Ingress Controller: Installed
              - Cert-Manager: Installed
              - MySQL: Configured
              - Firewall: Configured

              Next Steps:
              - Apply Kubernetes manifests for application deployment.
              - Configure DNS records for {{ domain_name }}
  handlers:
    - name: reload sysctl
      command: sysctl --system

    - name: restart docker
      systemd:
        name: docker
        state: restarted

    - name: restart containerd
      systemd:
        name: containerd
        state: restarted
